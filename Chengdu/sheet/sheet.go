package sheet

import (
	"encoding/json"
	"image"

	//just for register
	_ "image/jpeg"

	//just for register
	_ "image/png"

	"path/filepath"
	"strings"

	"golang.org/x/mobile/app"
	"golang.org/x/mobile/sprite"
)

//Frames standard for  sub texture's meta info in a atlas.
type Frames map[string]struct {
	Frame struct {
		X int `json:"x"`
		Y int `json:"y"`
		W int `json:"w"`
		H int `json:"h"`
	}
	Size struct {
		W int `json:"w"`
		H int `json:"h"`
	} `json:"sourceSize"`
}

//Meta standard for atlas's meta info.
type Meta struct {
	Version string `json:"version"`
	Image   string `json:"image"`
	Format  string `json:"format"`
	Size    struct {
		W int `json:"w"`
		H int `json:"h"`
	} `json:"size"`
	Scale string `json:"scale"`
}

//AtlasConfig is the configure read from (json-hash file) which generated by TexturePacker.
//
type SheetConfig struct {
	Meta   `json:"meta"`
	Frames `json:"frames"`
}

//Atlas implements a texture atlas.
type Sheet struct {
	tex     sprite.Texture
	subTexs map[string]*sprite.SubTex
}

func isaLegalMeta(meta string) bool {
	return strings.ToLower(filepath.Ext(meta)) == "json"
}

func isaLegalSheet(sheet string) bool {
	ext := strings.ToLower(filepath.Ext(sheet))

	return ext == "png" || ext == "jpg" || ext == "jpeg"
}

//NewAtlas new a atlas with meta info.
func newSheet(eng sprite.Engine, meta, sheet string) *Sheet {
	if !isaLegalMeta(meta) {
		return nil
	}
	if !isaLegalSheet(sheet) {
		return nil
	}

	file, err := app.Open(sheet)
	if err != nil {
		return nil
	}
	defer file.Close()

	img, _, err := image.Decode(file)
	if err != nil {
		return nil
	}
	t, err := eng.LoadTexture(img)
	if err != nil {
		return nil
	}

	a := &Sheet{
		tex:     t,
		subTexs: make(map[string]*sprite.SubTex),
	}

	if !a.init(meta, t) {
		return nil
	}

	return a

}

func (a *Sheet) init(meta string, t sprite.Texture) bool {
	if meta == "" || t == nil {
		return false
	}

	file, err := app.Open(meta)
	if err != nil {
		return false
	}
	defer file.Close()

	var conf SheetConfig

	decoder := json.NewDecoder(file)

	if err = decoder.Decode(&conf); err != nil {
		return false
	}

	for k, v := range conf.Frames {
		subTex := &sprite.SubTex{
			T: a.tex,
			R: image.Rect(v.Frame.X, v.Frame.Y, v.Frame.W, v.Frame.H),
		}
		a.subTexs[k] = subTex
	}

	return true

}

//SubTex get the sub texture with the specific name.
func (a *Sheet) SubTex(name string) *sprite.SubTex {
	tex, _ := a.subTexs[name]
	return tex
}
